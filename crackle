#!/bin/bash
PKG_PATH=${PKG_PATH:-$HOME/.local/share/crackle};
PKGS_DIR=${PKGS_DIR:-$PKG_PATH/var/log};
APTCACHE=${APTCACHE:-$HOME/.cache/crackle};
APTCONFIG=${APTCONFIG:-$HOME/.config/crackle};
CRACKLERC=$APTCONFIG/cracklerc;
CRACKLEENV=$APTCONFIG/crackle_environment;
CRACKLECMP=$APTCONFIG/crackle_completion;
CRACKDIR=${CRACKDIR:-$HOME/packages/$2};
SCRP_DIR=$(dirname "${BASH_SOURCE[0]}")
APT_GET="apt-get -o Dir::Cache=$APTCACHE -o Dir::State=$APTCACHE -o Dir::Etc=$APTCONFIG"
APT_CACHE="apt-cache -o Dir::Cache=$APTCACHE -o Dir::State=$APTCACHE -o Dir::Etc=$APTCONFIG"
source "$SCRP_DIR/triplet";
TRIPLET=$(get_architecture);

[ "$1" = "clean" ] && {
    $APT_GET "$1";
    find -L "$PKG_PATH"/bin -wholename "$PKG_PATH"/bin -o -type d -prune -o -type l -exec rm {} +;
    find -L "$PKG_PATH"/lib -wholename "$PKG_PATH"/lib -o -type d -prune -o -type l -exec rm {} +;
    exit 0;
}

[ "$1" = "setup" ] && {
    bashrc=$(grep crackle "$HOME"/.bashrc);
    profile=$(grep crackle "$HOME"/.profile);
    bashcompletion=$(grep crackle "$HOME"/.bash_completion);
    [[ -d "$PKGS_DIR" && -d "$APTCACHE" && -n "$bashrc" && -n "$profile" && -d "$APTCONFIG" && -f "$CRACKLERC" ]] && { echo "crackle is already set up"; exit 0; }
    [[ -d "$PKGS_DIR" ]] || mkdir -p "$PKGS_DIR";
    [[ -d "$PKG_PATH/bin" ]] || mkdir -p "$PKG_PATH/bin";
    [[ -d "$APTCACHE" ]] || mkdir -p "$APTCACHE";
    [[ -d "$APTCONFIG" ]] || { mkdir -p $APTCONFIG/sources.list.d $APTCONFIG/preferences.d; ln -s /etc/apt/sources.list $APTCONFIG; }
    [[ -f "$CRACKLERC" ]] || {
        echo "TRIPLET=$TRIPLET" > "$CRACKLERC";
        echo "PKG_PATH=$PKG_PATH" >> "$CRACKLERC";
        cat "$SCRP_DIR"/cracklerc >> "$CRACKLERC";
	echo ". $CRACKLEENV" >> "$CRACKLERC";
    }
    [[ -z "$bashrc" ]] && cat "$SCRP_DIR"/crackle.conf >> "$HOME"/.bashrc;
    [[ -z "$profile" ]] && cat "$SCRP_DIR"/crackle.conf >> "$HOME"/.profile;
    cp $SCRP_DIR/crackle $SCRP_DIR/triplet $SCRP_DIR/loginfo $PKG_PATH/bin
    [[ -d "$PKG_PATH/bin/scripts" ]] || mkdir "$PKG_PATH/bin/scripts";
    echo "PKG_PATH=$PKG_PATH" > $CRACKLECMP;
    cat "$SCRP_DIR/crackle_complete" >> $CRACKLECMP;
    [[ -z "$bashcompletion" ]] && echo ". $CRACKLECMP" >> ~/.bash_completion;
    # this just reloads bash the user doesn't have to
    "$SCRP_DIR"/crackle update || exit 1;
    if ! check_cmd git; then "$SCRP_DIR"/crackle install git; fi
    [[ -d "$SCRP_DIR"/bin/* ]] || { cd $SCRP_DIR;git submodule update --init; }
    cp -r "$SCRP_DIR"/bin/* "$PKG_PATH/bin/scripts"
    if ! check_cmd patchelf; then "$SCRP_DIR"/crackle install patchelf; fi
    echo "setup complete";
    exit 0;
}

[ "$1" = "update" ] && {
        wget -q --spider https://ubports.com || { echo no internet connection, please run crackle update later to fetch the latest package lists; exit 1; }
        $APT_GET "$1"|| { echo "crackle works best with a readonly rootfs please remount your rootfs"; exit 1; }
        exit 0;
}

[ "$1" = "download" ] && {
        $APT_GET "$1" "$2";
        exit 0;
}

[[ "$1" = "search" || "$1" = "show" ]] && {
        $APT_CACHE "$1" "$2";
        exit 0;
}

[[ "$1" = "install" || "$1" = "crack" ]] && {
    if [[ "$1" = "crack" ]]; then
        dir="$CRACKDIR";
    else
        dir="$PKG_PATH";
    fi
    [[ "$1" = "crack" && ! -d "$dir" ]] && mkdir "$dir";
    [ "$1" = "install" ] && {
            [ -d "$PKG_PATH" ] || { echo "$PKG_PATH does not exist, please run crackle setup first"; exit 1; }
    }
    [[ -d "$PKGS_DIR/$2" && "$1" = "install" ]] && {
        echo "fetching installed version.....";
        installed=$(cat $PKGS_DIR/$2/pkgs.version);
        echo "fetching candidate version.....";
        candidate=$($APT_CACHE policy $2|awk '/Candidate/{print $2}');
        echo "comparing.....";
        [[ "$installed" = "$candidate" ]] && { echo "$2" is already the newest version \($installed\); exit 0; }
    }
    $APT_GET install --download-only "$2" || {
            [ $? = 1 ] && exit 1;
	    echo if the above error is complaining about permission denied, do not run with sudo crackle doesn\'t require root! please remount your rootfs as readonly instead;
	    exit 100;
    };
    readarray -t packages < <(ls "$APTCACHE"/archives/*.deb);
    for package in "${packages[@]}"
    do
        . "$SCRP_DIR/loginfo";
        [[ "$1" = "install" ]] && PKGS_DIR=$PKGS_DIR log_pkg_info "$package";
	echo Unpacking $pkgname "("$pkgversion")"
        dpkg-deb -x "$package" "$dir";
    done;
    [[ -f "$PKG_PATH/bin/scripts/$2" ]] && { echo setting up $pkgname; PKG_PATH=$PKG_PATH TRIPLET=$TRIPLET CRACKLEENV=$CRACKLEENV "$PKG_PATH/bin/scripts/$2"; };
    echo cleaning packaging.....
    $APT_GET clean;
    echo done!
    exit 0;
}

[[ "$1" = "remove" ]] && {
    echo building dependency tree....;
    readarray -t packages < <($APT_CACHE depends "$2"| awk '/Depends/{print $2}');
    cat "$PKGS_DIR/$2/pkgs.list";
    rm -r "${PKGS_DIR:?}/$2";
    for package in "${packages[@]}"
    do
        [ -d "$PKGS_DIR/$package" ] && {
            cat "$PKGS_DIR/$package/pkgs.list";
            rm -r "${PKGS_DIR:?}/$package";
        }
    done;
}
echo "available commands:
- crackle setup
- crackle install
- crackle download
- crackle crack
- crackle clean
- crackle search
- crackle show
- crackle update
"
